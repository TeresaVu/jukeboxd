
<!DOCTYPE html>
<html>
<head>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/handlebars.js/2.0.0-alpha.1/handlebars.min.js"></script>
  <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
  <script src="https://sdk.scdn.co/spotify-player.js"></script>

  <title>Jukeboxd Player</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="background-style.css">
  <link rel="stylesheet" href="styles.css">
  <script>
      //jQuery stuff
      $(document).ready(function(){
        var childDiv = $(".hiddenFormMouseover");
        var throttle;
        var fadingIn = false;
        var isMouseOver = false;

        $(document).mousemove(function(event) {
            clearTimeout(throttle);

            if (!fadingIn && !isMouseOver) {
                fadingIn = true;
                childDiv.stop(true).fadeTo(500, 1, function() {
                    fadingIn = false;
                });
            }

            throttle = setTimeout(function() {
                if (!isMouseOver) {
                    childDiv.fadeTo(1000, 0.1);
                }
            }, 3000);
        });

        childDiv.mouseover(function() {
            $(this).stop().fadeTo(500, 1);
            clearTimeout(throttle);
            isMouseOver = true;
        });

        childDiv.mouseout(function() {
            throttle = setTimeout(function() {
                if (!isMouseOver) {
                    childDiv.fadeTo(1000, 0.1);
                }
            }, 3000);
            isMouseOver = false;
        });


        $('.comment').each(function() {
          var $this = $(this);
          $this.data('original-content', $this.text());
        });

        function checkForChanges() {
          $('.comment').each(function() {
            var $this = $(this);
            var originalContent = $this.data('original-content');
            var currentContent = $this.text();
            if (originalContent !== currentContent) {
                $this.fadeOut(3000).delay(500);
                // Optionally, you can update the original content if needed
                // $this.data('original-content', currentContent);
            }
          });
        }

        // Periodically check for changes
        setInterval(checkForChanges, 1000);
      });
  </script>
</head>

<body class="d-flex h-100 text-center text-white bg-dark">
  <div class="cover-container d-flex w-100 h-100 p-3 mx-auto flex-column">
    <div class="search">
                <input id="searchbar" type="text" class="form-control" placeholder="Search songs..." aria-label="Song Name" aria-describedby="basic-addon1" onkeyup="getSearchResults()" onblur="hideSearchResults()">
                <button id="searchResult1" class="searchResults" onclick="playSearchResult1()"><img id="searchResult1Image" src="" width="25px" height="25px" /><p id="searchResult1Text" style="display: inline"></p></button><br>
                <button id="searchResult2" class="searchResults" onclick="playSearchResult2()"><img id="searchResult2Image" src="" width="25px" height="25px" /><p id="searchResult2Text" style="display: inline"></p></button><br>
                <button id="searchResult3" class="searchResults" onclick="playSearchResult3()"><img id="searchResult3Image" src="" width="25px" height="25px" /><p id="searchResult3Text" style="display: inline"></p></button><br>
                <button id="searchResult4" class="searchResults" onclick="playSearchResult4()"><img id="searchResult4Image" src="" width="25px" height="25px" /><p id="searchResult4Text" style="display: inline"></p></button><br>
                <button id="searchResult5" class="searchResults" onclick="playSearchResult5()"><img id="searchResult5Image" src="" width="25px" height="25px" /><p id="searchResult5Text" style="display: inline"></p></button>
    </div>
    <script>
      var hide = document.getElementsByClassName("searchResults");
                for(var i = 0; i < hide.length; i++) {
                  hide[i].style.visibility = "hidden";
                }
      var searchBar = document.getElementById("searchbar");
      searchBar.addEventListener("keypress", function(event) {
        if(event.key === "Enter") {
          event.preventDefault();
          document.getElementById("searchbutton").click();
        }
      });
    </script>
      <!-- <header class="mb-auto"> -->
        <!-- <div> -->

          <!-- <nav class="nav nav-masthead justify-content-center float-md-start">
            <div class="input-group">
              <div class="input-group mb-3 searchbar hiddenFormMouseover">
                          <input id="searchbar" type="text" class="form-control" placeholder="Search songs..." aria-label="Song Name" aria-describedby="basic-addon1">
                <div class="input-group-append">
                  <button id="searchbutton" class="btn btn-primary" type="button" onclick="getSearchResults()">Search</button> -->
                  <!-- <div class="input-group mb-3 searchbar hiddenFormMouseover"> -->
                    <!-- <button id="searchbutton" class="btn btn-primary" type="button" onclick="getSearchResults()">Search</button> -->
                <!-- </div>
            </div>
          </nav>
          <br>
        </div> -->
      <!-- </header> -->
    
      <main class="px-3">
        <!-- Start of top comemnts section -->
        <div class="container">
          <div class="row">
            <div class="col">
              <p id="comment1" class="comment"></p>
            </div>
            <div class="col-6 justify-content-center">
              <p id="comment2" class="comment"></p>
            </div>
            <div class="col">
              <p id="comment3" class="comment"></p>
            </div>
          </div>
        </div>
        
        <div class="row">
          <p id="currentlyPlaying"></p>
        </div>

        <div class="row">
          <div class="col">
            <p id="comment4" class="comment"></p>
          </div>
          <div class="col-6">
            <!-- currently playing -->
            <img id="currentTrackImage" src="" alt="" width="200px" height="200px"><br>
            <img id="previousTrack" src="./imgs/previous-removebg-preview.png" class="next-button" />
            <img id="togglePlay" src="./imgs/play2-removebg-preview.png" class="play-button" />
            <img id="nextTrack" src="./imgs/next-removebg-preview.png" class="previous-button" />
            <br>
          </div>
          <div class="col">
            <p id="comment5" class="comment"></p>
          </div>
        </div>
        <!-- <p id="currentlyPlaying"></p>
        <img id="currentTrackImage" src="" alt="" width="200px" height="200px"><br>
        <img id="previousTrack" src="./imgs/previous-removebg-preview.png" class="next-button" />
        <img id="togglePlay" src="./imgs/play2-removebg-preview.png" class="play-button" />
        <img id="nextTrack" src="./imgs/next-removebg-preview.png" class="previous-button" />
        <br>--->
        
        <div class="container">
          <div class="row">
            <div class="col-md">
              <div class="progress-container">
                <span class="timestamp" id="current-time">0:00</span>
                <div class="progress-bar-container">
                  <div class="progress-bar" id="progress-bar"></div>
                </div>
                <span class="timestamp" id="total-duration">0:00</span>
              </div>
              <br>
            </div>
          </div>
        </div>

        <div class="container ">
          <div class="row hiddenFormMouseover">
              <label>Add Comment:</label>
          </div>
          <div class="row justify-content-md-center">
            <div class="col-md-auto hiddenFormMouseover">
              <div class="input-group mb-3">
                <input id="commentInput" type="text" class="form-control" placeholder="Type here..." aria-label="Add comments" aria-describedby="basic-addon2">
                <div class="input-group-append">
                  <button class="btn btn-secondary" type="button" onclick="addComment()">Post</button>
                </div>
              </div>
            </div>
          </div>
          <div class="row">
            <div class="col">
              <p id="comment6" class="comment"></p>
            </div>
            <div class="col-8">
              <label>Toggle Comments:</label>
            </div>
            <div class="col">
              <p id="comment7" class="comment"></p>
            </div>
          </div>

          <div class="row justify-content-md-center">
              <!-- Toggle User comments, all comments, no comments. Ajax to refresh the page comments immediately? -->
              <div class="input-group mb-3 justify-content-center">
                <select class="custom-select" id="inputGroupSelect03">
                  <option selected value="all">All</option>
                  <option value="own">Your Own</option>
                  <option value="none">None</option>
                </select>
              </div>
          </div>
        </div>

        <div class="container">
          <div class="row">
            <div class="col">
              <p id="comment8" class="comment"></p>
            </div>
            <div class="col-8">
              <p id="comment9" class="comment"></p>
            </div>
            <div class="col">
              <p id="comment10" class="comment"></p>
            </div>
          </div>
        </div>

          <script>
            var searchToken;
            var searchResult1_trackid;
            var searchResult2_trackid;
            var searchResult3_trackid;
            var searchResult4_trackid;
            var searchResult5_trackid;

            function hideSearchResults() {
              var hide = document.getElementsByClassName("searchResults");
              for(var i = 0; i < hide.length; i++) {
                hide[i].style.visibility = "hidden";
              }
              document.getElementById("searchbar").value = "";
            }

            function getSearchResults() {
              //console.log(searchToken);
              if(!document.getElementById("searchbar").value) {
                hideSearchResults();
              }
              else {
                var show = document.getElementsByClassName("searchResults");
                for(var i = 0; i < show.length; i++) {
                  show[i].style.visibility = "visible";
                }
              }
              const query = document.getElementById("searchbar").value;
              console.log(query);
              const queryURL = encodeURI(`q=${query}`);
              fetch(`https://api.spotify.com/v1/search?${queryURL}&type=track&limit=5`, {
                method: "GET",
                headers: {
                  Authorization: `Bearer ${searchToken}`
                }
              })
              .then(response => {
                if(!response.ok) {
                  throw Error("Response Not Ok")
                }
                return response;
              })
              .then(response => response.json())
              .then(({tracks}) => {
                console.log(tracks.items[0].album.images[0].url);
                searchResult1_trackid = tracks.items[0].id;
                document.getElementById("searchResult1Image").setAttribute("src", tracks.items[0].album.images[0].url);
                searchResult2_trackid = tracks.items[1].id;
                document.getElementById("searchResult2Image").setAttribute("src", tracks.items[1].album.images[0].url);
                searchResult3_trackid = tracks.items[2].id;
                document.getElementById("searchResult3Image").setAttribute("src", tracks.items[2].album.images[0].url);
                searchResult4_trackid = tracks.items[3].id;
                document.getElementById("searchResult4Image").setAttribute("src", tracks.items[3].album.images[0].url);
                searchResult5_trackid = tracks.items[4].id;
                document.getElementById("searchResult5Image").setAttribute("src", tracks.items[4].album.images[0].url);
                for(let i = 0; i < tracks.items.length; i++) {
                  console.log(tracks.items[i].name + " by " + tracks.items[i].artists[0].name + " id: " +tracks.items[i].id);
                  document.getElementById("searchResult" + (i+1).toString() + "Text").innerHTML = "  " + tracks.items[i].name + " by " + tracks.items[i].artists[0].name;
                }
              })
            };

            function playSearchResult1() {
              console.log("trying to play song with id: " + searchResult1_trackid);
              const uri = "spotify:track:" + searchResult1_trackid;
              console.log(uri);
              fetch(`https://api.spotify.com/v1/me/player/play`, {
                method: "PUT",
                headers: {
                  Authorization: `Bearer ${searchToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ // Convert body to JSON string
                    uris: [uri]
                })
              })
              .then(response => {
                if(!response.ok) {
                  throw Error("Response Not Ok")
                }
                return response.json();
              })
              .then(data => {
                  // Handle successful response
              })
              .catch(error => {
                  // Handle errors
                  console.error('Error:', error);
              });
            }

            function playSearchResult2() {
              console.log("trying to play song with id: " + searchResult2_trackid);
              const uri = "spotify:track:" + searchResult2_trackid;
              console.log(uri);
              fetch(`https://api.spotify.com/v1/me/player/play`, {
                method: "PUT",
                headers: {
                  Authorization: `Bearer ${searchToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ // Convert body to JSON string
                    uris: [uri]
                })
              })
              .then(response => {
                if(!response.ok) {
                  throw Error("Response Not Ok")
                }
                return response.json();
              })
              .then(data => {
                  // Handle successful response
              })
              .catch(error => {
                  // Handle errors
                  console.error('Error:', error);
              });
            }

            function playSearchResult3() {
              console.log("trying to play song with id: " + searchResult3_trackid);
              const uri = "spotify:track:" + searchResult3_trackid;
              console.log(uri);
              fetch(`https://api.spotify.com/v1/me/player/play`, {
                method: "PUT",
                headers: {
                  Authorization: `Bearer ${searchToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ // Convert body to JSON string
                    uris: [uri]
                })
              })
              .then(response => {
                if(!response.ok) {
                  throw Error("Response Not Ok")
                }
                return response.json();
              })
              .then(data => {
                  // Handle successful response
              })
              .catch(error => {
                  // Handle errors
                  console.error('Error:', error);
              });
            }

            function playSearchResult4() {
              console.log("trying to play song with id: " + searchResult4_trackid);
              const uri = "spotify:track:" + searchResult4_trackid;
              console.log(uri);
              fetch(`https://api.spotify.com/v1/me/player/play`, {
                method: "PUT",
                headers: {
                  Authorization: `Bearer ${searchToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ // Convert body to JSON string
                    uris: [uri]
                })
              })
              .then(response => {
                if(!response.ok) {
                  throw Error("Response Not Ok")
                }
                return response.json();
              })
              .then(data => {
                  // Handle successful response
              })
              .catch(error => {
                  // Handle errors
                  console.error('Error:', error);
              });
            }

            function playSearchResult5() {
              console.log("trying to play song with id: " + searchResult5_trackid);
              const uri = "spotify:track:" + searchResult5_trackid;
              console.log(uri);
              fetch(`https://api.spotify.com/v1/me/player/play`, {
                method: "PUT",
                headers: {
                  Authorization: `Bearer ${searchToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ // Convert body to JSON string
                    uris: [uri]
                })
              })
              .then(response => {
                if(!response.ok) {
                  throw Error("Response Not Ok")
                }
                return response.json();
              })
              .then(data => {
                  // Handle successful response
              })
              .catch(error => {
                  // Handle errors
                  console.error('Error:', error);
              });
            }
            
            (function() {
      
              /**
               * Obtains parameters from the hash of the URL
               * @return Object
               */
              function getHashParams() {
                var hashParams = {};
                var e, r = /([^&;=]+)=?([^&;]*)/g,
                    q = window.location.hash.substring(1);
                while ( e = r.exec(q)) {
                  hashParams[e[1]] = decodeURIComponent(e[2]);
                }
                return hashParams;
              }
      
              var params = getHashParams();
      
              var access_token = params.access_token,
                  refresh_token = params.refresh_token,
                  error = params.error;

              var userid = '';
              searchToken = access_token;
      
              if (error) {
                alert('There was an error during the authentication');
              } else {
                if (access_token) {

                  $.ajax({
                      url: 'https://api.spotify.com/v1/me',
                      headers: {
                          'Authorization': 'Bearer ' + access_token
                      },
                      success: function(response) {
                          // Call your server endpoint /adduser here
                          userid = response.id;
                          $.ajax({
                              url: '/adduser', // Replace with the correct URL of your server endpoint
                              type: 'POST', // Adjust the HTTP method as needed
                              contentType: 'application/JSON',
                              data: JSON.stringify(response), // Pass the response data to your server
                              success: function(responseFromServer) {
                                  // Handle the response from your server if needed
                              },
                              error: function(xhr, status, error) {
                                  // Handle errors if the request to your server fails
                                  console.error("Request to add user failed.");
                                  console.error(error);
                              }
                          });
                      },
                      error: function(xhr, status, error) {
                          // Handle errors if the request to the Spotify API fails
                          console.error(error);
                      }
                  });
                } else {
                    // render initial screen
                    $('#login').show();
                    $('#loggedin').hide();
                }
      
                // document.getElementById('obtain-new-token').addEventListener('click', function() {
                //   $.ajax({
                //     url: '/refresh_token',
                //     data: {
                //       'refresh_token': refresh_token
                //     }
                //   }).done(function(data) {
                //     access_token = data.access_token;
                //   });
                // }, false);
              }
              window.onSpotifyWebPlaybackSDKReady = () => {
                const token = access_token;
                console.log(token);
                const player = new Spotify.Player({
                    name: 'Web Playback SDK Quick Start Player',
                    getOAuthToken: cb => { cb(token); },
                    volume: 0.5
                });

                // Ready
                player.addListener('ready', ({ device_id }) => {
                    console.log('Ready with Device ID', device_id);
                    setDevice(device_id, () => {
                      const progress = setInterval(getStatePosition, 100); // start the interval for getting the state's position after the device has been set
                    // get the list of comments and their timestamps and poll the state's position to display the commment when it hits the timestamp
                    });
                });

                // Not Ready
                player.addListener('not_ready', ({ device_id }) => {
                    console.log('Device ID has gone offline', device_id);
                });

                player.addListener('initialization_error', ({ message }) => {
                    console.error(message);
                });

                player.addListener('authentication_error', ({ message }) => {
                    console.error(message);
                });

                player.addListener('account_error', ({ message }) => {
                    console.error(message);
                });

                var currState = {};
                var pressedPlay = false;
                var initial = true;
                var pressedPrev = false;
                var pressedNext = false;
                var trackChanged = false;
                var currTrack = "";
                var animationSpeed = 0;
                var currSong = '';
                var commentsArray = [];
                var songMap = [];
                var commentsIntervalId = -1;
                var commentsIntervalActive = false;

                player.addListener('player_state_changed', state => {
                  
                  if ((currSong !== state.track_window.current_track.name) || getStatePosition() < 1000) { // check if the position is less than 1 sec into the song
                    // song has changed or restarted
                    
                    currSong = state.track_window.current_track.name;
                    const trackId = state.track_window.current_track.id;
                    var display = document.getElementById("inputGroupSelect03")
                    display = display.options[display.selectedIndex].value;
                    // call get comments for this song
                    $.ajax({
                        url: '/getcomments',
                        type: 'GET',
                        data: {trackId: trackId, display: display, userID: userid},
                        success: function(responseFromServer) {
                            // Handle the response from your server if needed
                            console.log(responseFromServer);
                            commentsArray = responseFromServer;
                            songMap = constructSongMap(commentsArray, Math.floor(state.duration / 1000));
                        },
                        error: function(xhr, status, error) {
                            // Handle errors if the request to your server fails
                            console.error("Request to get comments failed.");
                        }
                    });
                  }
                  currState.paused = state.paused;
                  if(state.paused) {
                    if (commentsIntervalId !== -1) {
                      console.log("interval cleared", commentsIntervalId);
                      clearInterval(commentsIntervalId); // stop the loop that is checking if a comment exists at the current timestamp
                      commentsIntervalActive = false;
                    }
                    document.getElementById('togglePlay').setAttribute("src", "./imgs/play2-removebg-preview.png");
                    pauseAnimation();
                  }
                  
                  else {
                    // if a displayComment loop is not already going, set a new one. otherwise don't set a new loop, just let the current one keep looping
                    if (!commentsIntervalActive) { 
                      commentsIntervalId = setInterval(displayComment, 1000);
                      commentsIntervalActive = true;
                      console.log("interval set", commentsIntervalId);
                    }
                    document.getElementById('togglePlay').setAttribute("src", "./imgs/pause-removebg-preview.png");
                    resumeAnimation();

                    // if the song is playing, check every second if the current position matches the next comment's timestamp.
                    // ideas:
                    // - originally thought to store comments in a queue and pop when the comment passes the current timestamp,
                    // but does not work if the song restarts because the commentsQueue does not reset if the same song restarts, only when the song changes
                    // - instead, store the comments in an array, sorted by timestamp, and binary search for the comment with the matching timestamp...for the timestamp retrieved every second?
                    // that's inefficient. retrieval of the comment is O(mlogn) where n is num comments and m is num seconds in a song
                    // - OR create a sort of bitmap. an array, size of num seconds in the song, and mark each second that has a comment.
                    // associate the comment number in the bitmap with the index of the comment in the comments array to get the comment content. 
                    // O(n) for setting up the bitmap with the comments. retrieval is O(1).
                    
                    
                  }

                  currState.position = state.position;
                  currState.duration = state.duration;
                  currState.updateTime = performance.now();

                  oldTrack = currTrack;

                  showCurrentlyPlaying();

                  if ((!state.paused && !pressedPlay && (pressedNext || pressedPrev)) || initial || trackChanged) {
                    updateBackground();
                    //clear comments
                    clearComments();
                    initial = false;
                    pressedPlay = false;
                    pressedNext = false;
                    pressedPrev = false;
                    trackChanged = false;
                  }
                });

                document.getElementById('previousTrack').onclick = async function() {
                  pressedPrev = true;
                  await player.previousTrack().then(() => {
                    pressedPrev = false;
                  });
                  clearComments();
                };

                document.getElementById('togglePlay').onclick = function() {
                  pressedPlay = true;
                  player.togglePlay();
                };

                document.getElementById('nextTrack').onclick = async function() {
                  pressedNext = true;

                  await player.nextTrack().then(() => {
                    pressedNext = false; 
                  });
                  clearComments();
                };

                player.connect();


                async function updateBackground() {
                  const songFeatures = await getCurrentTrackFeatures();

                  var gradient = "linear-gradient(-45deg, ";
                  var newColors = [];

                  // get new colors               
                  var valence = songFeatures[1];
                  var energy = songFeatures[2];
                  var danceability = songFeatures[3];

                  // if high valence, high energy, and low dancibility -> warm colors
                  if (valence > .5 && energy > .5 && danceability < .6) {
                    for (var i = 0; i < 4; i++) {
                      var newColor;
                      do {
                          newColor = getWarmColor();
                      } while (newColors.indexOf(newColor) !== -1);
                      newColors.push(newColor);
                    }
                  }
                  // if high valence, high energy, and high dancibility -> vibrant
                  else if (valence > .5 && energy > .5 && danceability > .5) {
                    for (var i = 0; i < 4; i++) {
                      var newColor;
                      do {
                          newColor = getVibrantColor();
                      } while (newColors.indexOf(newColor) !== -1);
                      newColors.push(newColor);
                    }
                  }
                  // if low valence, low energy, low dancibility -> cool colors
                  else if (valence < .5 && energy < .5 && danceability < .5) {
                    for (var i = 0; i < 4; i++) {
                      var newColor;
                      do {
                          newColor = getCoolColor();
                      } while (newColors.indexOf(newColor) !== -1);
                      newColors.push(newColor);
                    }
                  }
                  // if high valence and low energy -> pastel
                  else if (valence > .5 && energy < .5) {
                    for (var i = 0; i < 4; i++) {
                      var newColor;
                      do {
                          newColor = getPastelColor();
                      } while (newColors.indexOf(newColor) !== -1);
                      newColors.push(newColor);
                    }
                  }
                  // low valence, high energy, and high danceability - > dark colors
                  else if (valence < .5 && energy > .5 && danceability > .5) {
                    for (var i = 0; i < 4; i++) {
                      var newColor;
                      do {
                          newColor = getDarkColor();
                      } while (newColors.indexOf(newColor) !== -1);
                      newColors.push(newColor);
                    }
                  }
                  // else random
                  else {
                    for (var i = 0; i < 4; i++) {
                      var newColor;
                      do {
                          newColor = getRandomColor();
                      } while (newColors.indexOf(newColor) !== -1);
                      newColors.push(newColor);
                    }
                  }

                  for (var i = 0; i < newColors.length; i++) {
                      gradient += newColors[i];
                      if (i !== newColors.length - 1) {
                          gradient += ", ";
                      }
                  }

                  gradient += ")";

                  document.body.style.background = gradient;

                  // add animation properties
                  document.body.style.backgroundSize = "400% 400%";

                  animationSpeed = songFeatures[0];
                  animationSpeed = 650 / animationSpeed; // adjusts animation speed based on tempo
                  document.body.style.backgroundSize = "400% 400%";
                  document.body.style.animation = "gradient " + animationSpeed + "s ease infinite";
                }

                function pauseAnimation() {
                  document.body.style.animation = "gradient 200s ease infinite";
                }

                function resumeAnimation() {
                  document.body.style.animation = "gradient " + animationSpeed + "s ease infinite";
                }

                // returns random color
                function getRandomColor() {
                  var letters = '0123456789ABCDEF';
                  var color = '#';
                  for (var i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                  }
                  return color;
                }

                function getWarmColor() {
                  var hue;
                  do {
                      hue = Math.floor(Math.random() * 360); 
                  } while (!((hue >= 0 && hue <= 30) || (hue >= 330 && hue <= 360))); // random hue between 0-30° or 300-360°
                  
                  var saturation = Math.floor(Math.random() * 50) + 50; // random saturation between 50% and 100%
                  var lightness = Math.floor(Math.random() * 20) + 40; // random lightness between 40% and 60%
                  return hslToHex(hue, saturation, lightness);
                }

                function getCoolColor() {
                    var hue;
                    do {
                        hue = Math.floor(Math.random() * 360); // random hue between 150°-270°
                    } while (!((hue >= 160 && hue <= 270)));
                    
                    var saturation = Math.floor(Math.random() * 50) + 50; // random saturation between 50% and 100%
                    var lightness = Math.floor(Math.random() * 50) + 15; // random lightness between 15% and 65%
                    return hslToHex(hue, saturation, lightness);
                }

                function getPastelColor() {
                    var hue = Math.floor(Math.random() * 360); // random hue between 0°-360°
                    var saturation = Math.floor(Math.random() * 30) + 70; // random saturation between 70% and 100%
                    var lightness = Math.floor(Math.random() * 15) + 75; // random lightness between 75% and 90%
                    return hslToHex(hue, saturation, lightness);
                }

                function getDarkColor() {
                    var hue;
                    do {
                      hue = Math.floor(Math.random() * 360); 
                  } while (!((hue >= 0 && hue <= 60) || (hue >= 120 && hue <= 360))); // random hue between 0-60° or 120-360°
                    var saturation = Math.floor(Math.random() * 50) + 40; // random saturation between 40% and 100%
                    var lightness = Math.floor(Math.random() * 45) + 15; // random lightness between 15% and 60%
                    return hslToHex(hue, saturation, lightness);
                }

                function getVibrantColor() {
                    var hue = Math.floor(Math.random() * 360); // random hue between 0°-360°
                    var saturation = Math.floor(Math.random() * 30) + 70; // random saturation between 70% and 100%
                    var lightness = Math.floor(Math.random() * 15) + 45; // random lightness between 45% and 60%
                    return hslToHex(hue, saturation, lightness);
                }

                function hslToHex(h, s, l) { // converts hsl color parameters to hex code of color
                    h /= 360;
                    s /= 100;
                    l /= 100;
                    let r, g, b;
                    if (s === 0) {
                        r = g = b = l;
                    } else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1 / 6) return p + (q - p) * 6 * t;
                            if (t < 1 / 2) return q;
                            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                            return p;
                        };
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1 / 3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1 / 3);
                    }
                    const toHex = (x) => {
                        const hex = Math.round(x * 255).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    };
                    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                }


                // track features used to determine color of bg
                async function getCurrentTrackFeatures() {
                  const state = await player.getCurrentState();
                  if (!state) {
                    console.error('User is not playing music through the Web Playback SDK');
                    return;
                  }

                  const current_track_id = state.track_window.current_track.id;
                  var songFeatures = [];
                  var track_tempo = 0;
                  var track_valence = 0;
                  var track_energy = 0;
                  var track_danceability = 0;
                  var track_id = "";

                  // gets current track features 
                  await $.ajax({
                    url: 'https://api.spotify.com/v1/audio-features/' + current_track_id,
                    type: 'GET',
                    headers: {
                      'Authorization': 'Bearer ' + access_token
                    },
                    success: function(response) {
                      track_tempo = response.tempo;

                      track_valence = response.valence;

                      track_energy = response.energy;

                      track_danceability = response.danceability;
                      
                      track_id = response.id;
                    }
                  });

                  // adds features into an array
                  songFeatures[0] = track_tempo;
                  songFeatures[1] = track_valence;
                  songFeatures[2] = track_energy;
                  songFeatures[3] = track_danceability;
                  return songFeatures;
                }  

                // Function to update the timestamp and song's duration
                function updateTimestampAndDuration(position, duration) {
                  const currentTimeElement = document.getElementById('current-time');
                  const totalTimeElement = document.getElementById('total-duration');
                  
                  const currentTime = formatTime(position);
                  const totalTime = formatTime(duration);
                  
                  currentTimeElement.textContent = currentTime;
                  totalTimeElement.textContent = totalTime;
                }

                // Function to format time in MM:SS format
                function formatTime(time) {
                  const minutes = Math.floor(time / 1000 / 60);
                  const seconds = Math.floor(time / 1000 % 60);
                  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                }

                function getStatePosition() {
                  if (currState.paused) {
                    return currState.position ? currState.position : 0;
                  }
                  let position = currState.position + (performance.now() - currState.updateTime);
                  if (isNaN(position)) {
                    console.log('Position is NaN. Resetting position to 0.');
                    position = 0;
                  }
                  if (isNaN(currState.duration)) {
                    currState.duration = 0;
                  }
                  setProgressBar(position);
                  updateTimestampAndDuration(position, currState.duration);
                  return position > currState.duration ? currState.duration : position;
                }

                function setProgressBar(position) {
                  const progressBar = document.getElementById('progress-bar');
                  const duration = currState.duration;
                  const percentage = (position / duration) * 100;
                  progressBar.style.width = percentage + '%';
                }
          
                // ensures that the player is connected to spotify without the user having to manually connect it on a spotify application
                function setDevice(device_id, callback) {
                  $.ajax({
                    url: 'https://api.spotify.com/v1/me/player',
                    type: 'PUT',
                    data: JSON.stringify({ device_ids: [device_id] }),
                    headers: {
                      'Authorization': 'Bearer ' + access_token,
                      'Content-Type': 'application/json'
                    },
                    success: function(response) {
                      console.log('Device set for playback:', device_id);
                      callback(); // executes the setInterval which calls getStatePosition periodically
                    },
                    error: function(xhr, status, error) {
                      console.error('Error setting device:', error);
                    }
                  });
                }

                function showCurrentlyPlaying() {
                  player.getCurrentState().then(state => {
                  if (!state) {
                    console.error('User is not playing music through the Web Playback SDK');
                    return;
                  }

                  var current_track = state.track_window.current_track;
                  var next_track = state.track_window.next_tracks[0];

                  var artistNames = current_track.artists[0].name;
                  for (let i = 1; i < current_track.artists.length; i++) {
                    artistNames = artistNames.concat(", ", current_track.artists[i].name);
                  }
                  document.getElementById("currentlyPlaying").innerHTML = "".concat("Currently Playing: ", current_track.name).concat(" by ", artistNames); 
                  // Displaying the image of the current track
                  var albumImage = current_track.album.images[0].url;
                  var imageElement = document.getElementById("currentTrackImage");
                  if (albumImage) {
                    // If there is an image URL, display the image
                    imageElement.src = albumImage;
                    imageElement.alt = "Current Track Image";
                    imageElement.style.display = "inline"; // Show the image
                  } else {
                    // If there is no image URL, hide the image element
                    imageElement.style.display = "none";
                  }

                  //updating names of curr and prev track
                  if (initial) {
                    currTrack = current_track.name;
                  }
                  else if (currTrack != current_track.name) {
                    trackChanged = true;
                    currTrack = current_track.name;
                  }
                  });
                }

                async function addComment() {
                  const state = await player.getCurrentState();
                  const songID = state.track_window.current_track.id;
                  var commentTimestamp = ((getStatePosition()) / 1000);
                  var comment = document.getElementById("commentInput").value;

                  console.log(JSON.stringify({"songID":songID, "userID": userid, "comment":comment, "timestamp":commentTimestamp}));

                  $.ajax({
                    url: '/addcomment', // Replace with the correct URL of your server endpoint
                    type: 'POST', // Adjust the HTTP method as needed
                    contentType: 'application/JSON',
                    data: JSON.stringify({"songID":songID, "userID": userid, "comment":comment, "timestamp":commentTimestamp}), // Pass the response data to your server
                    success: function(responseFromServer) {
                        // Handle the response from your server if needed
                    },
                    error: function(xhr, status, error) {
                        // Handle errors if the request to your server fails
                        console.error("Request to add comment failed.");
                        console.error(error);
                    }
                  });

                  document.getElementById("commentInput").value = "";
                }

                // check if there is a comment at the provided timestamp (ms)
                // if there is, display the comment
                function displayComment() {
                  console.log("comments interval id:", commentsIntervalId);
                  const currTime = Math.floor(getStatePosition() / 1000);
                  console.log(currTime);

                  var displayname;

                  var currUserID = songMap[currTime].userID;

                  $.ajax({
                    url: 'https://api.spotify.com/v1/users/' + currUserID,
                    headers: {
                        'Authorization': 'Bearer ' + access_token
                    },
                    success: function(response) {
                        // Call your server endpoint /adduser here
                        displayname = response.display_name;
                        if (songMap[currTime] !== false) {
                          //randomize where the comment should go.
                          //comment 1-9
                          //save an array of current commentid displayed, check against is and get a new display?
                          var commentID = Math.floor(Math.random() * 10) + 1;
                          console.log("commentid" + commentID);
                          console.log("comment:", songMap[currTime].comment);
                          $("#comment" + commentID).fadeIn(0);
                          document.getElementById("comment" + commentID).textContent = songMap[currTime].comment + " - " + currUserID;
                        }
                    },
                    error: function(xhr, status, error) {
                        // Handle errors if the request to the Spotify API fails
                        console.error(error);
                    }
                  });
                  
                }

                // return an array where the size is the number of seconds in the song and it is filled with false values and comment jsons
                // false if there is no comment at that second and a comment json if there is a comment at that second
                function constructSongMap(comments, songLengthSec) {
                  var numComments = comments.length;
                  let songMap = new Array(songLengthSec).fill(false);
                  for (let i = 0; i < comments.length; i++) {
                    var timestamp = comments[i].songTimestamp;
                    songMap[timestamp] = comments[i];
                  }

                  return songMap;
                }

                function clearComments() {
                  for(let i = 1; i < 10; i++) {
                    document.getElementById("comment" + i).textContent = "";
                  }
                }

                window.addComment = addComment;

              }
            })();
          </script>
      </main>
    
      <footer class="mt-auto text-white-50">
        <p>A Hot Dog Devs Production</p>
      </footer>
    </div>
</body>
</html>
